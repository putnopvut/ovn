AT_BANNER([ovn-controller])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - ovn-bridge-mappings])
AT_KEYWORDS([ovn])
ovn_start
net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

# Waits until the OVS database contains exactly the specified patch ports.
# Each argument should be of the form BRIDGE PORT PEER.
check_patches () {
    # Generate code to check that the set of patch ports is exactly as
    # specified.
    echo 'ovs-vsctl -f csv -d bare --no-headings --columns=name find Interface type=patch | sort' > query
    for patch
    do
        echo $patch
    done | cut -d' ' -f 2 | sort > expout

    # Generate code to verify that the configuration of each patch
    # port is correct.
    for patch
    do
        set $patch; bridge=$1 port=$2 peer=$3
        echo >>query "ovs-vsctl iface-to-br $port -- get Interface $port type options"
        echo >>expout "$bridge
patch
{peer=$peer}"
    done

    # Run the query until we get the expected result (or until a timeout).
    #
    # (We use sed to drop all "s from output because ovs-vsctl quotes some
    # of the port names but not others.)
    AT_CAPTURE_FILE([query])
    AT_CAPTURE_FILE([expout])
    AT_CAPTURE_FILE([stdout])
    OVS_WAIT_UNTIL([. ./query | sed 's/"//g' > stdout #"
                    diff -u stdout expout >/dev/null])
}

# Make sure that the configured bridge mappings in the Open_vSwitch db
# is mirrored into the Chassis record in the OVN_Southbound db.
check_bridge_mappings () {
    local_mappings=$1
    sysid=$(ovs-vsctl get Open_vSwitch . external_ids:system-id)
    OVS_WAIT_UNTIL([test x"${local_mappings}" = x$(ovn-sbctl get Chassis ${sysid} other_config:ovn-bridge-mappings | sed -e 's/\"//g')])
}

# NOTE: This test originally ran with only the SB-DB and no northd. For the
# test to be successfull with SSL+RBAC we need to initially run northd to get
# the RBAC rules programmed into the SB-DB. The test instruments the SB-DB
# directly and we need to stop northd to avoid overwriting the instrumentation.
kill `cat northd/ovn-northd.pid`
kill `cat northd-backup/ovn-northd.pid`
kill `cat ovn-nb/ovsdb-server.pid`

# Initially there should be no patch ports.
check_patches

# Configure two ovn-bridge mappings, but no patch ports should be created yet
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0,physnet2:br-eth1])
check_bridge_mappings "physnet1:br-eth0,physnet2:br-eth1"
check_patches

# Create a localnet port, but we should still have no patch ports, as they
# won't be created until there's a localnet port on a logical switch with
# another logical port bound to this chassis.
ovn-sbctl \
    -- --id=@dp101 create Datapath_Binding tunnel_key=101 \
    -- create Port_Binding datapath=@dp101 logical_port=localnet1 tunnel_key=1 \
        type=localnet options:network_name=physnet1
check_patches

# Create a localnet port on a logical switch with a port bound to this chassis.
# Now we should get some patch ports created.
ovn-sbctl \
    -- --id=@dp102 create Datapath_Binding tunnel_key=102 \
    -- create Port_Binding datapath=@dp102 logical_port=localnet2 tunnel_key=1 \
        type=localnet options:network_name=physnet1 \
    -- create Port_Binding datapath=@dp102 logical_port=localvif2 tunnel_key=2
ovs-vsctl add-port br-int localvif2 -- set Interface localvif2 external_ids:iface-id=localvif2
check_patches \
    'br-int  patch-br-int-to-localnet2 patch-localnet2-to-br-int' \
    'br-eth0 patch-localnet2-to-br-int patch-br-int-to-localnet2'

# Add logical patch ports to connect new logical datapath.
#
# OVN no longer uses OVS patch ports to implement logical patch ports, so
# the set of OVS patch ports doesn't change.
AT_CHECK([ovn-sbctl \
    -- --id=@dp1 create Datapath_Binding tunnel_key=1 \
    -- --id=@dp2 create Datapath_Binding tunnel_key=2 \
    -- create Port_Binding datapath=@dp1 logical_port=foo tunnel_key=1 type=patch options:peer=bar \
    -- create Port_Binding datapath=@dp2 logical_port=bar tunnel_key=2 type=patch options:peer=foo \
    -- create Port_Binding datapath=@dp1 logical_port=dp1vif tunnel_key=3 \
| uuidfilt], [0], [<0>
<1>
<2>
<3>
<4>
])
ovs-vsctl add-port br-int dp1vif -- set Interface dp1vif external_ids:iface-id=dp1vif
check_patches \
    'br-int  patch-br-int-to-localnet2 patch-localnet2-to-br-int' \
    'br-eth0 patch-localnet2-to-br-int patch-br-int-to-localnet2'

# Delete the mapping and the ovn-bridge-mapping patch ports should go away.
AT_CHECK([ovs-vsctl remove Open_vSwitch . external-ids ovn-bridge-mappings])
check_bridge_mappings
check_patches

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

# Checks that ovn-controller populates datapath-type and iface-types
# correctly in the Chassis other_config column.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - Chassis other_config])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

sysid=$(ovs-vsctl get Open_vSwitch . external_ids:system-id)

# Make sure that the datapath_type set in the Bridge table
# is mirrored into the Chassis record in the OVN_Southbound db.
check_datapath_type () {
    datapath_type=$1
    chassis_datapath_type=$(ovn-sbctl get Chassis ${sysid} other_config:datapath-type | sed -e 's/"//g') #"
    test "${datapath_type}" = "${chassis_datapath_type}"
}

OVS_WAIT_UNTIL([check_datapath_type ""])

ovs-vsctl set Bridge br-int datapath-type=foo
OVS_WAIT_UNTIL([check_datapath_type foo])

# Change "ovn-bridge-mappings" value. It should not change the "datapath-type".
ovs-vsctl set Open_vSwitch . external_ids:ovn-bridge-mappings=foo-mapping
check_datapath_type foo

ovs-vsctl set Bridge br-int datapath-type=bar
OVS_WAIT_UNTIL([check_datapath_type bar])

ovs-vsctl set Bridge br-int datapath-type=\"\"
OVS_WAIT_UNTIL([check_datapath_type ""])

# Set the datapath_type in external_ids:ovn-bridge-datapath-type.
ovs-vsctl set Open_vSwitch . external_ids:ovn-bridge-datapath-type=foo
OVS_WAIT_UNTIL([check_datapath_type foo])

# Change the br-int's datapath type to bar.
# It should be reset to foo since ovn-bridge-datapath-type is configured.
ovs-vsctl set Bridge br-int datapath-type=bar
OVS_WAIT_UNTIL([test foo = `ovs-vsctl get Bridge br-int datapath-type`])
OVS_WAIT_UNTIL([check_datapath_type foo])

ovs-vsctl set Open_vSwitch . external_ids:ovn-bridge-datapath-type=foobar
OVS_WAIT_UNTIL([test foobar = `ovs-vsctl get Bridge br-int datapath-type`])
OVS_WAIT_UNTIL([check_datapath_type foobar])

expected_iface_types=$(ovs-vsctl get Open_vSwitch . iface_types | tr -d '[[]] ""')
echo "expected_iface_types = ${expected_iface_types}"
chassis_iface_types=$(ovn-sbctl get Chassis ${sysid} other_config:iface-types | sed -e 's/\"//g')
echo "chassis_iface_types = ${chassis_iface_types}"
AT_CHECK([test "${expected_iface_types}" = "${chassis_iface_types}"])

# Change the value of other_config:iface-types using ovn-sbctl.
# ovn-controller should again set it back to proper one.
ovn-sbctl set Chassis ${sysid} other_config:iface-types="foo"
OVS_WAIT_UNTIL([
    chassis_iface_types=$(ovn-sbctl get Chassis ${sysid} other_config:iface-types | sed -e 's/\"//g')
    echo "chassis_iface_types = ${chassis_iface_types}"
    test "${expected_iface_types}" = "${chassis_iface_types}"
])

# Change the value of external_ids:system-id.
# This requires operator intervention and removal of the stale chassis and
# chassis_private records.  Until that happens ovn-controller fails to
# create the records due to constraint violation on the Encap table.
sysid=${sysid}-foo
current_remote=`ovs-vsctl get Open_vSwitch . external-ids:ovn-remote`
if test X$HAVE_OPENSSL = Xyes; then
    # To change chassis name we need to change certificate with matching CN
    ovs-vsctl set-ssl \
        $PKIDIR/testpki-${sysid}-privkey.pem \
        $PKIDIR/testpki-${sysid}-cert.pem \
        $PKIDIR/testpki-cacert.pem
    # force reconnect which makes OVN controller read the new certificates
    # TODO implement check for change of certificates in ovn-controller
    # and remove this workaround.
    ovs-vsctl set Open_vSwitch . external-ids:ovn-remote=unix:/dev/null
fi
ovs-vsctl -- set Open_vSwitch . external-ids:hostname="${sysid}" \
          -- set Open_vSwitch . external-ids:system-id="${sysid}" \
          -- set Open_vSwitch . external-ids:ovn-remote="${current_remote}"

OVS_WAIT_UNTIL([
    grep -q 'Transaction causes multiple rows in \\"Encap\\" table to have identical values' hv/ovn-controller.log
])

# Destroy the stale entries manually and ovn-controller should now be able
# to create new ones.
check ovn-sbctl destroy chassis_private . -- destroy chassis .

wait_row_count Chassis_Private 1 name=${sysid}
wait_row_count Chassis 1 name=${sysid}

# Only one Chassis_Private/Chassis record should exist.
wait_row_count Chassis_Private 1
wait_row_count Chassis 1

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

# Checks that ovn-controller correctly maintains the mapping from the Encap
# table in the Southbound database to OVS in the face of changes on both sides
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - change Encap properties])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

check_tunnel_property () {
    test "`ovs-vsctl get interface ovn-fakech-0 $1`" = "$2"
}

# Start off with a remote chassis supporting STT
ovn-sbctl chassis-add fakechassis stt 192.168.0.2
OVS_WAIT_UNTIL([check_tunnel_property type stt])

# See if we switch to Geneve as the first choice when it is available
# With multi-VTEP support we support tunnels with different IPs to the
# same chassis, and hence use the IP to annotate the tunnel (along with
# the chassis-id in ovn-chassis-id); if we supply a different IP here
# we won't be able to co-relate this to the tunnel port that was created
# in the previous step and, as a result, will end up creating another tunnel,
# ie. we can't just lookup using "ovn-fakech-0". So, need to use the same IP
# as above, i.e 192.168.0.2, here.
encap_uuid=$(ovn-sbctl add chassis fakechassis encaps @encap -- --id=@encap create encap type=geneve ip="192.168.0.2")
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

# Check that changes within an encap row are propagated
ovn-sbctl set encap ${encap_uuid} ip=192.168.0.2
OVS_WAIT_UNTIL([check_tunnel_property options:remote_ip "\"192.168.0.2\""])

# Change the type on the OVS side and check than OVN fixes it
ovs-vsctl set interface ovn-fakech-0 type=vxlan
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

# Delete the port entirely and it should be resurrected
ovs-vsctl del-port ovn-fakech-0
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

# Check ovn-controller connection status to Southbound database
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - check sbdb connection])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

check_sbdb_connection () {
    test "$(ovs-appctl -t ovn-controller connection-status)" = "$1"
}

OVS_WAIT_UNTIL([check_sbdb_connection connected])

ovs-vsctl set open . external_ids:ovn-remote=tcp:192.168.0.10:6642
OVS_WAIT_UNTIL([check_sbdb_connection 'not connected'])

# reset the remote for clean-up
ovs-vsctl set open . external_ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock
# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

# Checks that ovn-controller recreates its chassis record when deleted externally.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - Chassis self record])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])
# Delete the chassis "hv"
ovn-sbctl chassis-del hv
# ovn-controller should recreate its chassis row.
OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP

# Checks that ovn-controller increments the nb_cfg value in the Chassis_Private table
AT_SETUP([ovn-controller - Bump Chassis_Private nb_cfg value])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])

# Bump the NB_Global nb_cfg value
nb_global_id=$(ovn-nbctl --columns _uuid --bare find nb_global)
ovn-nbctl set NB_Global ${nb_global_id} nb_cfg=999

# ovn-controller should bump the nb_cfg in the chassis_private table
OVS_WAIT_UNTIL([test x999 = x`ovn-sbctl --columns nb_cfg --bare find chassis_private`])

# Assert that the the nb_cfg from the Chassis table was not incremented
OVS_WAIT_UNTIL([test x0 = x`ovn-sbctl --columns nb_cfg --bare find chassis`])

OVN_CLEANUP([hv])
AT_CLEANUP
])

# Test unix command: debug/delay-nb-cfg-report
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - debug/delay-nb-cfg-report])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])

AT_CHECK([ovn-appctl -t ovn-controller debug/delay-nb-cfg-report 2], [0],
         [delay nb_cfg report for 2 seconds.
])

AT_FAIL_IF([ovn-nbctl --timeout=1 --wait=hv sync])

# sleep another 1 sec so that the original 2 sec sleep is done in ovn-controller
sleep 1

AT_CHECK([ovn-nbctl --timeout=3 --wait=hv sync])

AT_CHECK([ovn-appctl -t ovn-controller debug/delay-nb-cfg-report 0], [0],
         [no delay for nb_cfg report.
])

AT_CHECK([ovn-nbctl --timeout=1 --wait=hv sync])

OVN_CLEANUP([hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- nb_cfg sync to OVS])
ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Wait for ovn-controller to register in the SB.
wait_row_count Chassis 1

# Increment nb_cfg.
check ovn-nbctl --wait=hv sync

# And check that it gets propagated to br-int external_ids.
as hv1
OVS_WAIT_UNTIL([ovs-vsctl get Bridge br-int external_ids:ovn-nb-cfg], [0], [1])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- features])
AT_KEYWORDS([features])
ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Wait for ovn-controller to register in the SB.
OVS_WAIT_UNTIL([
    test "$(ovn-sbctl get chassis hv1 other_config:port-up-notif)" = '"true"'
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Test that changes of a port binding from one type to another doesn'that
# result in any ovn-controller asserts or crashes.
AT_SETUP([ovn-controller - port binding type change handling])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl ls-add ls1 -- lsp-add ls1 lsp1

as hv1
check ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1

# ovn-controller should bind the interface.
wait_for_ports_up
hv_uuid=$(fetch_column Chassis _uuid name=hv1)
check_column "$hv_uuid" Port_Binding chassis logical_port=lsp1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[1]]
primary lport : [[lsp1]]
----------------------------------------
])

# pause ovn-northd
check as northd ovn-appctl -t ovn-northd pause
check as northd-backup ovn-appctl -t ovn-northd pause

as northd ovn-appctl -t ovn-northd status
as northd-backup ovn-appctl -t ovn-northd status

pb_types=(patch chassisredirect l3gateway localnet localport l2gateway
          virtual external remote vtep)
for type in ${pb_types[[@]]}
do
    for update_type in ${pb_types[[@]]}
    do
        check ovn-sbctl set port_binding lsp1 type=$type
        check as hv1 ovs-vsctl set open . external_ids:ovn-cms-options=$type
        OVS_WAIT_UNTIL([test $type = $(ovn-sbctl get chassis . other_config:ovn-cms-options)])

        AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[0]]
----------------------------------------
])

        echo "Updating to $update_type from $type"
        check ovn-sbctl set port_binding lsp1 type=$update_type
        check as hv1 ovs-vsctl set open . external_ids:ovn-cms-options=$update_type
        OVS_WAIT_UNTIL([test $update_type = $(ovn-sbctl get chassis . other_config:ovn-cms-options)])

        AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[0]]
----------------------------------------
])
        # Set the port binding type back to VIF.
        check ovn-sbctl set port_binding lsp1 type=\"\"
        check as hv1 ovs-vsctl set open . external_ids:ovn-cms-options=foo
        OVS_WAIT_UNTIL([test foo = $(ovn-sbctl get chassis . other_config:ovn-cms-options)])

        AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[1]]
primary lport : [[lsp1]]
----------------------------------------
])
    done
done

OVN_CLEANUP([hv1])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- MAC bindings from router addresses])
ovn_start

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.$i.1
done

AS_BOX([Setting up the logical network])
# This test ties in heavily with the ovn-northd "Router Address
# Propagation" test. That test ensures that Port_Binding
# router_addresses are filled in as expected based on the logical
# network configuration.
#
# This test focuses on ensuring that router_addresses get
# converted to the expected MAC_Bindings, specifically with regards
# to ensuring they are created based on is_chassis_resident
# restrictions. Therefore, it is not necessary to ensure that an
# exhaustive set of logical network configurations is attempted for
# this test.

check ovn-nbctl ls-add sw

check ovn-nbctl lr-add ro1
check ovn-nbctl lrp-add ro1 ro1-sw 00:00:00:00:00:01 10.0.0.1/24
check ovn-nbctl lsp-add sw sw-ro1

check ovn-nbctl lr-add ro2
check ovn-nbctl lrp-add ro2 ro2-sw 00:00:00:00:00:02 20.0.0.1/24
check ovn-nbctl --wait=sb lsp-add sw sw-ro2

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 vm1
check ovn-nbctl lsp-set-addresses vm1 "00:00:00:00:01:02 172.16.1.2"
check ovn-nbctl lrp-add ro1 ro1-ls1 00:00:00:00:01:01 172.16.1.1/24
check ovn-nbctl lsp-add ls1 ls1-ro1
check ovn-nbctl lsp-set-type ls1-ro1 router
check ovn-nbctl lsp-set-addresses ls1-ro1 router
check ovn-nbctl lsp-set-options ls1-ro1 router-port=ro1-ls1

check ovn-nbctl ls-add ls2
check ovn-nbctl lsp-add ls2 vm2
check ovn-nbctl lsp-set-addresses vm2 "00:00:00:00:02:02 172.16.2.2"
check ovn-nbctl lrp-add ro2 ro2-ls2 00:00:00:00:02:01 172.16.2.1/24
check ovn-nbctl lsp-add ls2 ls2-ro2
check ovn-nbctl lsp-set-type ls2-ro2 router
check ovn-nbctl lsp-set-addresses ls2-ro2 router
check ovn-nbctl --wait=hv lsp-set-options ls2-ro2 router-port=ro2-ls2

as hv1
check ovs-vsctl add-port br-int vm1 -- set Interface vm1 external_ids:iface-id=vm1
as hv2
check ovs-vsctl add-port br-int vm2 -- set Interface vm2 external_ids:iface-id=vm2

AS_BOX([Checking that no router addresses results in no chassis-specific MAC Bindings])

check_row_count MAC_Binding 0 chassis_name=hv1
check_row_count MAC_Binding 0 chassis_name=hv2

AS_BOX([Checking that connecting routers results in no chassis-specific MAC Bindings])

check ovn-nbctl lsp-set-type sw-ro1 router
check ovn-nbctl lsp-set-addresses sw-ro1 router
check ovn-nbctl lsp-set-options sw-ro1 router-port=ro1-sw

check ovn-nbctl lsp-set-type sw-ro2 router
check ovn-nbctl lsp-set-addresses sw-ro2 router
check ovn-nbctl --wait=hv lsp-set-options sw-ro2 router-port=ro2-sw

check_row_count MAC_Binding 0 chassis_name=hv1
check_row_count MAC_Binding 0 chassis_name=hv2

AS_BOX([Checking that l3dgw routers have chassis-specific MAC Bindings])

check ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100
check ovn-nbctl --wait=hv lrp-set-gateway-chassis ro2-sw hv2 100

check_row_count MAC_Binding 1 chassis_name=hv1
check_row_count MAC_Binding 1 chassis_name=hv2

check_column "10.0.0.1" MAC_Binding ip chassis_name=hv1
check_column "00:00:00:00:00:01" MAC_Binding mac chassis_name=hv1
check_column "ro2-sw" MAC_Binding logical_port chassis_name=hv1

check_column "20.0.0.1" MAC_Binding ip chassis_name=hv2
check_column "00:00:00:00:00:02" MAC_Binding mac chassis_name=hv2
check_column "ro1-sw" MAC_Binding logical_port chassis_name=hv2

AS_BOX([Checking that NAT addresses result in chassis-specific MAC Bindings])

check ovn-nbctl lr-nat-add ro1 dnat 10.0.0.100 172.16.1.100
check ovn-nbctl --wait=hv lr-nat-add ro1 snat 10.0.0.200 172.16.1.200/30

# hv1 installs MAC bindings for the ro1's router address and two NAT addresses
check_row_count MAC_Binding 3 chassis_name=hv1
# hv2 only installs MAC bindings for ro2's router address
check_row_count MAC_Binding 1 chassis_name=hv2

check_column "10.0.0.1 10.0.0.100 10.0.0.200" MAC_Binding ip chassis_name=hv1
check_column "00:00:00:00:00:01 00:00:00:00:00:01 00:00:00:00:00:01" MAC_Binding mac chassis_name=hv1
check_column "ro2-sw ro2-sw ro2-sw" MAC_Binding logical_port chassis_name=hv1

check_column "20.0.0.1" MAC_Binding ip chassis_name=hv2
check_column "00:00:00:00:00:02" MAC_Binding mac chassis_name=hv2
check_column "ro1-sw" MAC_Binding logical_port chassis_name=hv2

AS_BOX([Checking that changing which router has NAT addresses results in correct MAC Bindings])

check ovn-nbctl lr-nat-del ro1

check ovn-nbctl lr-nat-add ro2 dnat 20.0.0.100 172.16.2.100
check ovn-nbctl --wait=hv lr-nat-add ro2 snat 20.0.0.200 172.16.2.200/30

# hv1 installs MAC bindings for ro1's router address
check_row_count MAC_Binding 1 chassis_name=hv1
# hv2 installs MAC bindings for ro2's router address and two NAT addresses
check_row_count MAC_Binding 3 chassis_name=hv2

check_column "10.0.0.1" MAC_Binding ip chassis_name=hv1
check_column "00:00:00:00:00:01" MAC_Binding mac chassis_name=hv1
check_column "ro2-sw" MAC_Binding logical_port chassis_name=hv1

check_column "20.0.0.1 20.0.0.100 20.0.0.200" MAC_Binding ip chassis_name=hv2
check_column "00:00:00:00:00:02 00:00:00:00:00:02 00:00:00:00:00:02" MAC_Binding mac chassis_name=hv2
check_column "ro1-sw ro1-sw ro1-sw" MAC_Binding logical_port chassis_name=hv2

AS_BOX([Checking that Floating IP NAT address configured on router results in MAC Binding])

check ovn-nbctl lr-nat-del ro2

check ovn-nbctl --wait=hv lr-nat-add ro1 dnat_and_snat 10.0.0.100 172.16.1.100 vm1 00:00:00:00:00:01

# HV1 will have MAC bindings for the router address and the Floating IP NAT since vm1 is bound on hv1
check_row_count MAC_Binding 2 chassis_name=hv1
check_row_count MAC_Binding 1 chassis_name=hv2

check_column "10.0.0.1 10.0.0.100" MAC_Binding ip chassis_name=hv1
check_column "00:00:00:00:00:01 00:00:00:00:00:01" MAC_Binding mac chassis_name=hv1
check_column "ro2-sw ro2-sw" MAC_Binding logical_port chassis_name=hv1

check_column "20.0.0.1" MAC_Binding ip chassis_name=hv2
check_column "00:00:00:00:00:02" MAC_Binding mac chassis_name=hv2
check_column "ro1-sw" MAC_Binding logical_port chassis_name=hv2

AS_BOX([Checking that un-binding vm results in removal of Floating IP MAC Binding])

as hv1
check ovs-vsctl del-port br-int vm1

# This will be exactly as if no NATs were configured.
# Use wait_row_count instead of check_row_count here since
# we don't have an equivalent to --wait=hv in ovs-vsctl.
wait_row_count MAC_Binding 1 chassis_name=hv1
check_row_count MAC_Binding 1 chassis_name=hv2

check_column "10.0.0.1" MAC_Binding ip chassis_name=hv1
check_column "00:00:00:00:00:01" MAC_Binding mac chassis_name=hv1
check_column "ro2-sw" MAC_Binding logical_port chassis_name=hv1

check_column "20.0.0.1" MAC_Binding ip chassis_name=hv2
check_column "00:00:00:00:00:02" MAC_Binding mac chassis_name=hv2
check_column "ro1-sw" MAC_Binding logical_port chassis_name=hv2

AS_BOX([Ensure that disconnecting routers results in removal of all MAC Bindings])

check ovn-nbctl clear logical_switch_port sw-ro1 options
check ovn-nbctl --wait=hv clear logical_switch_port sw-ro2 options

check_row_count MAC_Binding 0 chassis_name=hv1
check_row_count MAC_Binding 0 chassis_name=hv2

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])
